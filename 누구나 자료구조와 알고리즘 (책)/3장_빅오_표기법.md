

## **-3장- 빅오 표기법**

- 자료구조와 알고리즘을 간결하고 일관적인 언어로     
  설명하기 위해 형식화한 표현을 **빅오 표기법**이라 부른다.



<br />

#### 3.1 빅 오: 단계 수 계산    

- O(1) 
    - 일반적으로 **빅 오 1** 이라고 발음한다.
    - 배열읽기에 필요한 단계 수는 하나라는 의미다.

- O(N)
    - 일단 여기서는 "오 N" 이라 발음
    - 배열내에 N개의 원소가 있을 때 알고리즘을 끝내는데 N개의 단계가 필요

#### 3.2 상수 시간과 선형 시간    

- O(1) O(N)의 알고리즘의 그래프    
![3-1](https://github.com/DragooCho/TIL/blob/main/image/3-1.png?raw=true)<br /><br />

- O(N)을 선형 시간(linear time)
- O(1)을 상수 시간(constant time)<br /><br />   

- 이렇게 O(1)은 데이터가 아무리 커져도 단계 수가 변하지 않는 모든 알고리즘을 표현하는 방법이다.   
![3-2](https://github.com/DragooCho/TIL/blob/main/image/3-2.png?raw=true)

#### 3.2 같은 알고리즘, 다른 시나리오   

- 전체적인 관점에서 선형 검색의 효율성을 설명한다면    
  최선의 시나리오에서는 O(1), 최악의 시나리오에서는 O(N)이라 할 수 있다.    

![3-3](https://github.com/DragooCho/TIL/blob/main/image/3-3.png?raw=true)

#### 3.4 세 번째 유형의 알고리즘    

- 이진 검색은 O(1)과 O(N) 사이 어디쯤엔가 있다.

- O(log N)
    - 이진검색의 시간복잡도를 표현
    - 즉 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘을 빅 오로 표현함.

- 세 종류의 알고리즘을 비교하는 그래프    
  
![3-4](https://github.com/DragooCho/TIL/blob/main/image/3-4.png?raw=true)    
- 이러한 알고리즘을 왜 “O(log N)”이라 부르는지     
  이해하려면 먼저 로가리즘이 무엇인지 알아야 한다.

#### 3.4 로가리즘 
- 로그는 로가리즘(logarithm)의 줄임말이다. 
- 로가리즘은 지수와 역(inverse)의 관계
- 예시로 23은 2 * 2 * 2와 동치로서 값이 8이다.
- log28을 다른 방식으로 설명하면 이렇다.    
  1이 될 때까지 8을 2로 계속해서 나눌 때 등식에 얼마나 많은 2가 등장할까?

``````
8 / 2 / 2 / 2 = 1
``````
#### 3.6 O(log N) 해석    
- 로가리즘에 접목해서 이해해보자면    
   O(log N)은 원소가 하나가 될 때까지 데이터 원소를      
   계속해서 반으로 줄이는 만큼의 단계 수가 걸린다는 뜻
<br /><br /> 
![3-5](https://github.com/DragooCho/TIL/blob/main/image/3-5.png?raw=true)    
- O(N) 알고리즘에는 데이터 원소 수만큼의 단계가 필요한 반면,         
      O(log N) 알고리즘에는 데이터 원소가         
      두 배로 늘어날 때마다 딱 한 단계만 더 필요하다.   












