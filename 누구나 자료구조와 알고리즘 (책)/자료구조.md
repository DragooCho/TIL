## **-1장- 자료 구조가 중요한 까닭**

![https://github.com/DragooCho/TIL/raw/main/image/1-1.png](https://github.com/DragooCho/TIL/raw/main/image/1-1.png)

- 대부분의 자료구조는 **읽기, 검색, 삽입, 삭제** 네가지 기본구조를 사용. 이를 '연산'이라 한다.

- **배열 읽기**는 한 단계만에 끝내는 매우 효율적인 연산이다.

- 컴퓨터가 한번에 한셀씩 확인하는 방법을 **선형검색**이라 부른다.

- **집합**은 중복값을 허용하지않는 자료구조이다. 

  즉 중복 데이터를 허용하지 않는 자료구조에 적합하다.

  배열기반 집합에서 삽입 할려면 **검색이 우선**시 하는 특징이 있다. 

- 연산이 얼마나 빠른가를 측정하는것보다 얼마나 많은 ***단계(step)가 필요한가***를 따져야한다.
<br />
<br />
<br />
## **-2장- 알고리즘이 중요한 까닭**

- 알고리즘이란 단순히 문제를 해결하는 절차일뿐이다.
- 컴퓨터의 관점에서 알고리즘은 **특정연산을 풀어내는 절차**를 뜻한다.


<br />
#### 2.1 정렬된 배열(ordered array)

- 일반적인 배열과는 달리 값이 항상 **순서대로** 있어야 한다는 특징. 
- 정렬된 배열 예시 (75 숫자를 값의 순서를 고려해 넣을 경우)



![정렬된 배열 예시.png](https://github.com/DragooCho/TIL/blob/main/image/%EC%A0%95%EB%A0%AC%EB%90%9C%20%EB%B0%B0%EC%97%B4%20%EC%98%88%EC%8B%9C.png?raw=true)

- 실제 삽입할 올바른 위치를 정하기 위해 검색을 먼저 수행
- 일반배열보다 덜 효율적이나 검색연산에서의  강력함에 있다.


<br />
#### 2.2 정렬된 배열의 검색

- [17, 3, 75, 202, 80] 이라는 일반적인 배열이 있다고 할 때 

  22라는 값을 찾으려면 모든 원소를 검색해야 한다.

- 하지만 [3, 17, 75, 80, 202] 같은 정렬된 배열이라면 22라는 값보다 

  큰 값이 검색(여기서는 75)될 때 바로 검색을 중단 할 수 있다. 

- 일반적인 배열과 비교해 효율성에 큰 차이가 없어보이지만 

- 정말 두드러진 장점은 다른 알고리즘을 사용 할 수 있으며

  그것을 **이진 검색(binary search)**이라 부르며 선형검색보다 훨씬 빠르다.

  















